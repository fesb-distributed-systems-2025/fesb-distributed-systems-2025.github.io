"use strict";(self.webpackChunkdistributed_systems=self.webpackChunkdistributed_systems||[]).push([[374],{3905:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>d});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var s=a.createContext({}),c=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},u=function(e){var n=c(e.components);return a.createElement(s.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),m=c(t),d=r,k=m["".concat(s,".").concat(d)]||m[d]||p[d]||o;return t?a.createElement(k,l(l({ref:n},u),{},{components:t})):a.createElement(k,l({ref:n},u))}));function d(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=t.length,l=new Array(o);l[0]=m;var i={};for(var s in n)hasOwnProperty.call(n,s)&&(i[s]=n[s]);i.originalType=e,i.mdxType="string"==typeof e?e:r,l[1]=i;for(var c=2;c<o;c++)l[c]=t[c];return a.createElement.apply(null,l)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},9508:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>l,default:()=>p,frontMatter:()=>o,metadata:()=>i,toc:()=>c});var a=t(7462),r=(t(7294),t(3905));const o={},l="Lesson",i={unversionedId:"labs/Lab 2 - Synchronization/Lesson",id:"labs/Lab 2 - Synchronization/Lesson",title:"Lesson",description:"Table Of Contents",source:"@site/docs/labs/02.Lab 2 - Synchronization/Lesson.md",sourceDirName:"labs/02.Lab 2 - Synchronization",slug:"/labs/Lab 2 - Synchronization/Lesson",permalink:"/docs/labs/Lab 2 - Synchronization/Lesson",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Preparation",permalink:"/docs/labs/Lab 1 - Threads/Preparation"},next:{title:"Lesson",permalink:"/docs/labs/Lab 3 - Communication Protocols/Lesson"}},s={},c=[{value:"Table Of Contents",id:"table-of-contents",level:2},{value:"<strong>Exercise 1: Utilizing Multiple Cores</strong>",id:"exercise-1-utilizing-multiple-cores",level:2},{value:"<strong>Create a Project</strong>",id:"create-a-project",level:3},{value:"<strong>Run Project</strong>",id:"run-project",level:3},{value:"<strong>Exercise 2: Implementing Spin-Locks</strong>",id:"exercise-2-implementing-spin-locks",level:2},{value:"<strong>Create a Project</strong>",id:"create-a-project-1",level:3},{value:"<strong>Run the project</strong>",id:"run-the-project",level:3},{value:"<strong>Exercise 3: Using Kernel-mode Synchronizations</strong>",id:"exercise-3-using-kernel-mode-synchronizations",level:2},{value:"<strong>Create a Project</strong>",id:"create-a-project-2",level:3},{value:"<strong>Run the project</strong>",id:"run-the-project-1",level:3},{value:"<strong>Exercise 4: Producer and Consumer</strong>",id:"exercise-4-producer-and-consumer",level:2},{value:"<strong>Create a Project</strong>",id:"create-a-project-3",level:3},{value:"<strong>Run the project</strong>",id:"run-the-project-2",level:3},{value:"<strong>Exercise 5: Multiple Producers and Consumers</strong>",id:"exercise-5-multiple-producers-and-consumers",level:2},{value:"<strong>Create a Project</strong>",id:"create-a-project-4",level:3},{value:"<strong>Run the project</strong>",id:"run-the-project-3",level:3},{value:"<strong>Exercise 6: Provoking a Deadlock</strong>",id:"exercise-6-provoking-a-deadlock",level:2},{value:"<strong>Create a Project</strong>",id:"create-a-project-5",level:3},{value:"<strong>Run the project</strong>",id:"run-the-project-4",level:3},{value:"<strong>Exercise 7: Avoiding Deadlocks</strong>",id:"exercise-7-avoiding-deadlocks",level:2},{value:"<strong>Create a Project</strong>",id:"create-a-project-6",level:3},{value:"<strong>Run the project</strong>",id:"run-the-project-5",level:3},{value:"<strong>Homework</strong>",id:"homework",level:2},{value:"<strong>Setup</strong>",id:"setup",level:3}],u={toc:c};function p(e){let{components:n,...o}=e;return(0,r.kt)("wrapper",(0,a.Z)({},u,o,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"lesson"},"Lesson"),(0,r.kt)("h1",{id:"lab-2-synchronization"},"Lab 2: Synchronization"),(0,r.kt)("h2",{id:"table-of-contents"},"Table Of Contents"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#lesson"},"Lesson")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#lab-2-synchronization"},"Lab 2: Synchronization"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#table-of-contents"},"Table Of Contents")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#exercise-1-utilizing-multiple-cores"},(0,r.kt)("strong",{parentName:"a"},"Exercise 1: Utilizing Multiple Cores")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#create-a-project"},(0,r.kt)("strong",{parentName:"a"},"Create a Project"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#run-project"},(0,r.kt)("strong",{parentName:"a"},"Run Project"))))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#exercise-2-implementing-spin-locks"},(0,r.kt)("strong",{parentName:"a"},"Exercise 2: Implementing Spin-Locks")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#create-a-project-1"},(0,r.kt)("strong",{parentName:"a"},"Create a Project"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#run-the-project"},(0,r.kt)("strong",{parentName:"a"},"Run the project"))))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#exercise-3-using-kernel-mode-synchronizations"},(0,r.kt)("strong",{parentName:"a"},"Exercise 3: Using Kernel-mode Synchronizations")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#create-a-project-2"},(0,r.kt)("strong",{parentName:"a"},"Create a Project"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#run-the-project-1"},(0,r.kt)("strong",{parentName:"a"},"Run the project"))))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#exercise-4-producer-and-consumer"},(0,r.kt)("strong",{parentName:"a"},"Exercise 4: Producer and Consumer")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#create-a-project-3"},(0,r.kt)("strong",{parentName:"a"},"Create a Project"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#run-the-project-2"},(0,r.kt)("strong",{parentName:"a"},"Run the project"))))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#exercise-5-multiple-producers-and-consumers"},(0,r.kt)("strong",{parentName:"a"},"Exercise 5: Multiple Producers and Consumers")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#create-a-project-4"},(0,r.kt)("strong",{parentName:"a"},"Create a Project"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#run-the-project-3"},(0,r.kt)("strong",{parentName:"a"},"Run the project"))))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#exercise-6-provoking-a-deadlock"},(0,r.kt)("strong",{parentName:"a"},"Exercise 6: Provoking a Deadlock")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#create-a-project-5"},(0,r.kt)("strong",{parentName:"a"},"Create a Project"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#run-the-project-4"},(0,r.kt)("strong",{parentName:"a"},"Run the project"))))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#exercise-7-avoiding-deadlocks"},(0,r.kt)("strong",{parentName:"a"},"Exercise 7: Avoiding Deadlocks")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#create-a-project-6"},(0,r.kt)("strong",{parentName:"a"},"Create a Project"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#run-the-project-5"},(0,r.kt)("strong",{parentName:"a"},"Run the project"))))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#homework"},(0,r.kt)("strong",{parentName:"a"},"Homework")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#setup"},(0,r.kt)("strong",{parentName:"a"},"Setup")))))))),(0,r.kt)("h2",{id:"exercise-1-utilizing-multiple-cores"},(0,r.kt)("strong",{parentName:"h2"},"Exercise 1: Utilizing Multiple Cores")),(0,r.kt)("p",null,"In this exercise you will use methods from .NET framework to perform atomic (uninterruptable) updates on primitive data types."),(0,r.kt)("p",null,"The overheads of using threads:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Starting a thread"),(0,r.kt)("li",{parentName:"ol"},"Scheduling a thread (context switch)"),(0,r.kt)("li",{parentName:"ol"},"Synchronizing a thread (+ associated (big) problems)"),(0,r.kt)("li",{parentName:"ol"},"Cache misses"),(0,r.kt)("li",{parentName:"ol"},"Destroying a thread")),(0,r.kt)("p",null,"Advice: Avoid 1, 3, and 4!!!"),(0,r.kt)("p",null,"If you access shared variables (e.g. static and instance fields) you should use synchronization mechanisms."),(0,r.kt)("p",null,"Local variables are not shared unless they are passed to lambda expressions. In that case, local variables are implicitly captured into objects by the compiler."),(0,r.kt)("p",null,"Thread-safety in FCL methods:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"All FCL static methods are thread-safe. Most parameters are passed by value and FCL internally they use locks only if necessary."),(0,r.kt)("li",{parentName:"ul"},"Instance methods are not thread-safe since the overhead of locking would hurt performance.")),(0,r.kt)("p",null,"Primitives (methods) that are used for synchronization can be:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"User-mode constructs"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"They are fast since they use special CPU instructions to coordinate threads."),(0,r.kt)("li",{parentName:"ul"},"Windows and thread pool do not detect that a thread blocks using these synchronization primitives."),(0,r.kt)("li",{parentName:"ul"},"But, you cannot suspend a thread waiting on a user-mode synchronization primitive."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Kernel-mode constructs"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Synchronization primitives are implemented in the Windows kernel so a transition for user to kernel mode is executed."),(0,r.kt)("li",{parentName:"ul"},"The kernel is able to suspend threads that wait on these synchronization constructs."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Hybrid constructs"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Run as non-blocking when there is no contention. When there is a contention thread are blocked by the operating system.")))),(0,r.kt)("p",null,"In .NET you can use the following user-mode constructs:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Volatile Constructs"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"These constructs are used to perform atomic read or atomic write operations but they cannot be combined into atomic read/modify/write operations."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Interlocked operations"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"These constructs provide atomic read/modify/write operations.  They all are full memory fences.")))),(0,r.kt)("p",null,"A ",(0,r.kt)("strong",{parentName:"p"},"memory fence")," ensures that:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"All writes before an interlocked method are executed before the call to the Interlocked method."),(0,r.kt)("li",{parentName:"ul"},"All reads after the call to the interlocked method must execute after the call to the interlocked method.  ")),(0,r.kt)("h3",{id:"create-a-project"},(0,r.kt)("strong",{parentName:"h3"},"Create a Project")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Create a C# Console project, named ",(0,r.kt)("inlineCode",{parentName:"li"},"Synchronization.AtomicOperations")," in solution ",(0,r.kt)("inlineCode",{parentName:"li"},"Synchronization"),".")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"dotnet new sln --name Synchronization\ndotnet new console --name Synchronization.AtomicOperations\ndotnet sln add Synchronization.AtomicOperations/Synchronization.AtomicOperations.csproj\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Use the following namespaces in file ",(0,r.kt)("inlineCode",{parentName:"li"},"Program.cs"),":")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"using System;\nusing System.Threading;\nusing System.Threading.Tasks;\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Add following constants and fields to class ",(0,r.kt)("inlineCode",{parentName:"li"},"Program"),":")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"private const int IncrementAmount = 10_000;\nprivate static volatile int s_volatileSum;\nprivate static int s_interlockedSum;\nprivate static int s_normalSum;\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Implement method ",(0,r.kt)("inlineCode",{parentName:"li"},"IncrementSums")," as follows:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"private static void IncrementSums()\n{\n    for (var i = 0; i < IncrementAmount; i++)\n    {\n        s_volatileSum++;\n        _ = Interlocked.Increment(ref s_interlockedSum);\n        s_normalSum++;\n    }\n}\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Implement method ",(0,r.kt)("inlineCode",{parentName:"li"},"Main")," as follows:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'public static async Task Main()\n{\n    var numberOfCores = Environment.ProcessorCount;\n    Console.WriteLine($"You have {numberOfCores} cores installed.");\n\n    var tasks = new List<Task>();\n\n    foreach (var _ in Enumerable.Range(0, numberOfCores))\n    {\n        var task = Task.Run(IncrementSums);\n        tasks.Add(task);\n    }\n\n    await Task.WhenAll(tasks);\n\n    Console.WriteLine($"Volatile sum: {s_volatileSum}");\n    Console.WriteLine($"Interlocked sum: {s_interlockedSum}");\n    Console.WriteLine($"Normal sum: {s_normalSum}");\n}\n')),(0,r.kt)("h3",{id:"run-project"},(0,r.kt)("strong",{parentName:"h3"},"Run Project")),(0,r.kt)("p",null,"Execute the project and the output similar to the following will appear:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"$ dotnet run --project Synchronization.AtomicOperations/Synchronization.AtomicOperations.csproj\nYou have 10 cores installed.\nVolatile sum: 99769\nInterlocked sum: 100000\nNormal sum: 99989\n")),(0,r.kt)("h2",{id:"exercise-2-implementing-spin-locks"},(0,r.kt)("strong",{parentName:"h2"},"Exercise 2: Implementing Spin-Locks")),(0,r.kt)("p",null,"In this exercise you will use user level constructs to implement spin waiting."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"mutual-exclusion",src:t(3792).Z,width:"720",height:"540"})),(0,r.kt)("h3",{id:"create-a-project-1"},(0,r.kt)("strong",{parentName:"h3"},"Create a Project")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Create a C# Console project, named ",(0,r.kt)("inlineCode",{parentName:"li"},"Synchronization.InterlockedOperations")," in solution ",(0,r.kt)("inlineCode",{parentName:"li"},"Synchronization"),".")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"dotnet new console --name Synchronization.InterlockedOperations\ndotnet sln add Synchronization.InterlockedOperations/Synchronization.InterlockedOperations.csproj\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Use the following namespaces in file Program.cs:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"using System;\nusing System.Threading;\nusing System.Threading.Tasks;\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Add following implementation to method ",(0,r.kt)("inlineCode",{parentName:"li"},"AddNumbers"),":")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'    private static void AddNumbers()\n    {\n        var threadId = Environment.CurrentManagedThreadId;\n        while (Interlocked.Exchange(ref s_locker, 1) != 0)\n        {\n            Console.WriteLine($"Thread {threadId} is waiting for lock to release");\n            Thread.Sleep(300);\n        }\n\n        Console.WriteLine($"Thread {threadId} has acquired lock");\n\n        s_total += 5;\n        Console.WriteLine("total = " + s_total);\n\n        s_total -= 2;\n        Console.WriteLine("total = " + s_total);\n\n        s_total *= 2;\n        Console.WriteLine("total = " + s_total);\n\n        Console.WriteLine($"Thread {threadId} is about to release lock");\n        Thread.VolatileWrite(ref s_locker, 0);\n    }\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Add following implementation to method ",(0,r.kt)("inlineCode",{parentName:"li"},"Main"),":")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"    public static async Task Main()\n    {\n        var tasks = new[]\n        {\n            Task.Run(() => AddNumbers()),\n            Task.Run(() => AddNumbers()),\n            Task.Run(AddNumbers),\n        };\n\n        await Task.WhenAll(tasks);\n    }\n")),(0,r.kt)("h3",{id:"run-the-project"},(0,r.kt)("strong",{parentName:"h3"},"Run the project")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Execute the project and the output similar to the following will appear:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"$ dotnet run --project Synchronization.InterlockedOperations/Synchronization.InterlockedOperations.csproj\nThread 4 has acquired lock\nThread 6 is waiting for lock to release\ntotal = 5\ntotal = 3\ntotal = 6\nThread 7 is waiting for lock to release\nThread 4 is about to release lock\nThread 6 has acquired lock\ntotal = 11\ntotal = 9\ntotal = 18\nThread 6 is about to release lock\nThread 7 is waiting for lock to release\nThread 7 has acquired lock\ntotal = 23\ntotal = 21\ntotal = 42\nThread 7 is about to release lock\n")),(0,r.kt)("h2",{id:"exercise-3-using-kernel-mode-synchronizations"},(0,r.kt)("strong",{parentName:"h2"},"Exercise 3: Using Kernel-mode Synchronizations")),(0,r.kt)("p",null,"In this exercise you will use kernel mode synchronizations."),(0,r.kt)("h3",{id:"create-a-project-2"},(0,r.kt)("strong",{parentName:"h3"},"Create a Project")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Create a C# Console project, named ",(0,r.kt)("inlineCode",{parentName:"li"},"Synchronization.KernelSynchronizations")," in solution ",(0,r.kt)("inlineCode",{parentName:"li"},"Synchronization"),".")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"dotnet new console --name Synchronization.KernelSynchronizations\ndotnet sln add Synchronization.KernelSynchronizations/Synchronization.KernelSynchronizations.csproj\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Add following fields to class ",(0,r.kt)("inlineCode",{parentName:"li"},"Program"),":")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"    private static readonly AutoResetEvent s_autoRaiseEvent = new(false);\n    private static readonly Semaphore s_semaphore = new(1, 2);\n    private static readonly Random s_random = new();\n    private static readonly object s_lock = new();\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Add following implementation to method ",(0,r.kt)("inlineCode",{parentName:"li"},"DoSomething"),":")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'    private static void DoSomething()\n    {\n        Console.WriteLine("Waiting for auto raise event to be signaled ...");\n        _ = s_autoRaiseEvent.WaitOne();\n        Console.WriteLine("autoRaiseEvent is signaled.");\n    }\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Add following implementation to method ",(0,r.kt)("inlineCode",{parentName:"li"},"DoConcurrentOperationWithSemaphore"),":")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'    private static async Task DoConcurrentOperationWithSemaphore()\n    {\n        var managedThreadId = Environment.CurrentManagedThreadId;\n\n        try\n        {\n            Console.WriteLine($"Thread {managedThreadId} is waiting to enter semaphore");\n\n            _ = s_semaphore.WaitOne();\n\n            Console.WriteLine($"Thread {managedThreadId} entered semaphore");\n\n            await Task.Delay(TimeSpan.FromSeconds(1));\n\n            var randomNumber = s_random.Next(0, 3);\n\n            if (randomNumber == 1)\n            {\n                throw new NotSupportedException($"Uh oh, bad thing happened in thread {managedThreadId}");\n            }\n        }\n        catch (NotSupportedException)\n        {\n            Console.ForegroundColor = ConsoleColor.Red;\n            Console.WriteLine($"Exception occurred on thread {managedThreadId}");\n            Console.ResetColor();\n        }\n        finally\n        {\n            Console.WriteLine($"Thread {managedThreadId} is about to exit semaphore");\n            _ = s_semaphore.Release();\n        }\n    }\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Add following implementation to method ",(0,r.kt)("inlineCode",{parentName:"li"},"DoConcurrentOperationWithLock"),":")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'    private static void DoConcurrentOperationWithLock()\n    {\n        var managedThreadId = Environment.CurrentManagedThreadId;\n\n        Console.WriteLine($"Thread {managedThreadId} is waiting to enter lock");\n        lock (s_lock)\n        {\n            Console.WriteLine($"Thread {managedThreadId} entered lock");\n\n            Thread.Sleep(TimeSpan.FromSeconds(1));\n        }\n\n        Console.WriteLine($"Thread {managedThreadId} left lock");\n\n    }\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Add following implementation to method ",(0,r.kt)("inlineCode",{parentName:"li"},"Main"),":")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'    public static async Task Main()\n    {\n        var autoRaiseEventTask = Task.Run(DoSomething);\n\n        Console.WriteLine("Press any key to signal raise autoRaiseEvent signal ...");\n        _ = Console.ReadKey();\n\n        _ = s_autoRaiseEvent.Set();\n\n        await autoRaiseEventTask;\n\n        var semaphoreTasks = new[]\n        {\n            Task.Run(DoConcurrentOperationWithSemaphore),\n            Task.Run(DoConcurrentOperationWithSemaphore),\n            Task.Run(DoConcurrentOperationWithSemaphore),\n            Task.Run(DoConcurrentOperationWithSemaphore),\n            Task.Run(() => DoConcurrentOperationWithSemaphore()),\n        };\n        await Task.WhenAll(semaphoreTasks);\n\n        var lockTasks = new[]\n        {\n            Task.Run(DoConcurrentOperationWithLock),\n            Task.Run(DoConcurrentOperationWithLock),\n            Task.Run(() => DoConcurrentOperationWithLock()),\n        };\n        await Task.WhenAll(lockTasks);\n\n        s_autoRaiseEvent.Dispose();\n        s_semaphore.Dispose();\n    }\n')),(0,r.kt)("h3",{id:"run-the-project-1"},(0,r.kt)("strong",{parentName:"h3"},"Run the project")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Execute the project and the output similar to the following will appear:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"$ dotnet run --project Synchronization.KernelSynchronizations/Synchronization.KernelSynchronizations.csproj\nPress any key to signal raise autoRaiseEvent signal ...\nWaiting for auto raise event to be signaled ...\nautoRaiseEvent is signaled.\nThread 7 is waiting to enter semaphore\nThread 11 is waiting to enter semaphore\nThread 7 entered semaphore\nThread 12 is waiting to enter semaphore\nThread 8 is waiting to enter semaphore\nThread 9 is waiting to enter semaphore\nThread 7 is about to exit semaphore\nThread 11 entered semaphore\nThread 11 is about to exit semaphore\nThread 12 entered semaphore\nException occurred on thread 12\nThread 12 is about to exit semaphore\nThread 8 entered semaphore\nThread 8 is about to exit semaphore\nThread 9 entered semaphore\nException occurred on thread 9\nThread 9 is about to exit semaphore\nThread 12 is waiting to enter lock\nThread 12 entered lock\nThread 8 is waiting to enter lock\nThread 11 is waiting to enter lock\n")),(0,r.kt)("h2",{id:"exercise-4-producer-and-consumer"},(0,r.kt)("strong",{parentName:"h2"},"Exercise 4: Producer and Consumer")),(0,r.kt)("p",null,"In this exercise you will implement a classical synchronization problem."),(0,r.kt)("p",null,"A producer produces items and stores them in a shared buffer.\nThe consumer takes items from the buffer and consumes them."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"circular-buffer",src:t(1167).Z,width:"720",height:"540"}),"\n",(0,r.kt)("img",{alt:"coordinating-threads",src:t(6643).Z,width:"720",height:"540"})),(0,r.kt)("p",null,"The following steps are vital for the algorithm:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"When the buffer is full the producer goes to sleep"),(0,r.kt)("li",{parentName:"ul"},"When the buffer is empty the consumer goes to sleep"),(0,r.kt)("li",{parentName:"ul"},"When there is one empty slot in the buffer the consumer wakes up the producer"),(0,r.kt)("li",{parentName:"ul"},"When there is one full slot in the buffer the producer wakes up the consumer.")),(0,r.kt)("p",null,"The programmer should avoid ",(0,r.kt)("strong",{parentName:"p"},"deadlocks")," and/or ",(0,r.kt)("strong",{parentName:"p"},"starvation's"),"."),(0,r.kt)("h3",{id:"create-a-project-3"},(0,r.kt)("strong",{parentName:"h3"},"Create a Project")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Create a C# Console project, named ",(0,r.kt)("inlineCode",{parentName:"li"},"Synchronization.ProducerConsumer")," in solution ",(0,r.kt)("inlineCode",{parentName:"li"},"Synchronization"),":")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"dotnet new console --name Synchronization.ProducerConsumer\ndotnet sln add Synchronization.ProducerConsumer/Synchronization.ProducerConsumer.csproj\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Create and implement class ",(0,r.kt)("inlineCode",{parentName:"li"},"SharedBuffer")," in new file:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"using System;\nusing System.Threading;\n\nnamespace Synchronization.ProducerConsumer;\n\npublic class SharedBuffer\n{\n    private readonly int[] _buffer = new int[10];\n    private int _numberOfOccupiedElements;\n    private int _elementIndexToPut;\n    private int _elementIndexToTakeFrom;\n\n    private readonly object _locker = new();\n}\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"In class ",(0,r.kt)("inlineCode",{parentName:"li"},"SharedBuffer")," implement method ",(0,r.kt)("inlineCode",{parentName:"li"},"PutElement"),":")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'    public void PutElement(int element)\n    {\n        var managedThreadId = Environment.CurrentManagedThreadId;\n        lock (_locker)\n        {\n            while (_numberOfOccupiedElements == _buffer.Length)\n            {\n                Console.WriteLine($"Thread {managedThreadId} is waiting");\n                _ = Monitor.Wait(_locker);\n            }\n\n            _buffer[_elementIndexToPut] = element;\n            _numberOfOccupiedElements++;\n            _elementIndexToPut = (_elementIndexToPut + 1) % _buffer.Length;\n\n            for (var i = 0; i < _buffer.Length; i++)\n                Console.Write("{0:d2} ", _buffer[i]);\n            Console.WriteLine(" ");\n\n            Monitor.Pulse(_locker);\n        }\n    }\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"In class ",(0,r.kt)("inlineCode",{parentName:"li"},"SharedBuffer")," implement method ",(0,r.kt)("inlineCode",{parentName:"li"},"GetElement"),":")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'\n    public int GetElement()\n    {\n        var managedThreadId = Environment.CurrentManagedThreadId;\n\n        lock (_locker)\n        {\n            while (_numberOfOccupiedElements == 0)\n            {\n                Console.WriteLine($"Thread {managedThreadId} is waiting");\n                _ = Monitor.Wait(_locker);\n            }\n\n            var element = _buffer[_elementIndexToTakeFrom];\n            _buffer[_elementIndexToTakeFrom] = 0;\n            _numberOfOccupiedElements--;\n            _elementIndexToTakeFrom = (_elementIndexToTakeFrom + 1) % _buffer.Length;\n\n            for (var i = 0; i < _buffer.Length; i++)\n            {\n                Console.Write($"{_buffer[i]:d2} ");\n            }\n\n            Console.WriteLine("");\n\n            Monitor.Pulse(_locker);\n\n            return element;\n        }\n    }\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Create and implement class ",(0,r.kt)("inlineCode",{parentName:"li"},"Producer")," in new file:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"public class Producer\n{\n    private readonly SharedBuffer _buffer;\n    private readonly Random _random = new();\n\n    public Producer(SharedBuffer buffer)\n    {\n        _buffer = buffer;\n    }\n\n    public void Produce()\n    {\n        for (var i = 0; i < 100; i++)\n        {\n            Thread.Sleep(_random.Next(1, 200));\n            _buffer.PutElement(i);\n        }\n    }\n}\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Create and implement class ",(0,r.kt)("inlineCode",{parentName:"li"},"Consumer")," in new file:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'public class Consumer\n{\n    private readonly SharedBuffer _buffer;\n    private readonly Random _random = new();\n\n    public Consumer(SharedBuffer buffer)\n    {\n        _buffer = buffer;\n    }\n\n    public void Consume()\n    {\n        var sum = 0;\n\n        for (var i = 0; i < 100; i++)\n        {\n            Thread.Sleep(_random.Next(1, 500));\n            sum += _buffer.GetElement();\n        }\n\n        Console.WriteLine("Sum should be " + (99 * 100 / 2));\n        Console.WriteLine("Thank you kleine Karl: " + sum);\n    }\n}\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Add following fields to class ",(0,r.kt)("inlineCode",{parentName:"li"},"Program"),":")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"    private static readonly SharedBuffer s_buffer = new();\n    private static readonly Producer s_producer = new(s_buffer);\n    private static readonly Consumer s_consumer = new(s_buffer);\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Implement method ",(0,r.kt)("inlineCode",{parentName:"li"},"Main")," in class ",(0,r.kt)("inlineCode",{parentName:"li"},"Program"),":")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"    public static async Task Main()\n    {\n        var t1 = Task.Run(s_producer.Produce);\n        var t2 = Task.Run(s_consumer.Consume);\n\n        await Task.WhenAll(t1, t2);\n    }\n")),(0,r.kt)("h3",{id:"run-the-project-2"},(0,r.kt)("strong",{parentName:"h3"},"Run the project")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Execute the project and the output similar to the following will appear:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"$ dotnet run --project Synchronization.ProducerConsumer/Synchronization.ProducerConsumer.csproj\nThread 6 is waiting\n00 00 00 00 00 00 00 00 00 00\n00 00 00 00 00 00 00 00 00 00\n00 01 00 00 00 00 00 00 00 00\n00 00 00 00 00 00 00 00 00 00\n00 00 02 00 00 00 00 00 00 00\n00 00 02 03 00 00 00 00 00 00\n00 00 00 03 00 00 00 00 00 00\n00 00 00 03 04 00 00 00 00 00\n00 00 00 00 04 00 00 00 00 00\n00 00 00 00 04 05 00 00 00 00\n00 00 00 00 04 05 06 00 00 00\n00 00 00 00 04 05 06 07 00 00\n00 00 00 00 04 05 06 07 08 00\n00 00 00 00 00 05 06 07 08 00\n00 00 00 00 00 05 06 07 08 09\n10 00 00 00 00 05 06 07 08 09\n10 11 00 00 00 05 06 07 08 09\n10 11 12 00 00 05 06 07 08 09\n10 11 12 00 00 00 06 07 08 09\n10 11 12 13 00 00 06 07 08 09\n10 11 12 13 14 00 06 07 08 09\n10 11 12 13 14 00 00 07 08 09\n10 11 12 13 14 15 00 07 08 09\n10 11 12 13 14 15 00 00 08 09\n10 11 12 13 14 15 16 00 08 09\n...\n")),(0,r.kt)("h2",{id:"exercise-5-multiple-producers-and-consumers"},(0,r.kt)("strong",{parentName:"h2"},"Exercise 5: Multiple Producers and Consumers")),(0,r.kt)("p",null,"In this exercise you will use C# ",(0,r.kt)("inlineCode",{parentName:"p"},"System.Threading.Channels.Channel")," to implement multiple producers and consumers:"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"producers-consumers",src:t(9262).Z,width:"521",height:"141"})),(0,r.kt)("h3",{id:"create-a-project-4"},(0,r.kt)("strong",{parentName:"h3"},"Create a Project")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Create a C# Console project, named ",(0,r.kt)("inlineCode",{parentName:"li"},"Synchronization.MultipleProducersConsumers")," in solution ",(0,r.kt)("inlineCode",{parentName:"li"},"Synchronization"),":")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"dotnet new console --name Synchronization.MultipleProducersConsumers\ndotnet sln add Synchronization.MultipleProducersConsumers/Synchronization.MultipleProducersConsumers.csproj\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Create and implement class ",(0,r.kt)("inlineCode",{parentName:"li"},"Producer")," in new file:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'public class Producer\n{\n    private readonly Random _random = new();\n    private readonly string _name;\n    private readonly ChannelWriter<int> _channelWriter;\n\n    public Producer(string name, ChannelWriter<int> writer)\n    {\n        _name = name;\n        _channelWriter = writer;\n    }\n\n    public async Task Produce()\n    {\n        for (var i = 0; i < 100; i++)\n        {\n            var delay = TimeSpan.FromMilliseconds(_random.Next(1, 200));\n            await Task.Delay(delay);\n            await _channelWriter.WriteAsync(i);\n            Console.WriteLine($"Producer {_name} wrote {i} to channel.");\n        }\n    }\n}\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Create and implement class ",(0,r.kt)("inlineCode",{parentName:"li"},"Consumer")," in new file:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'public class Consumer\n{\n    private readonly Random _random = new();\n    private readonly string _name;\n    private readonly ChannelReader<int> _channelReader;\n\n    public Consumer(string name, ChannelReader<int> channelReader)\n    {\n        _name = name;\n        _channelReader = channelReader;\n    }\n\n    public async Task<int> Consume()\n    {\n        var sum = 0;\n\n        await foreach (var data in _channelReader.ReadAllAsync())\n        {\n            var delay = TimeSpan.FromMilliseconds(_random.Next(1, 500));\n            await Task.Delay(delay);\n            sum += data;\n            Console.WriteLine($"Consumer {_name} read {data} from channel.");\n        }\n\n        return sum;\n    }\n}\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Add following field to class ",(0,r.kt)("inlineCode",{parentName:"li"},"Program"),":")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"    private static readonly Channel<int> s_channel = Channel.CreateBounded<int>(new BoundedChannelOptions(10)\n    {\n        FullMode = BoundedChannelFullMode.Wait,\n    });\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Add following implementation to method ",(0,r.kt)("inlineCode",{parentName:"li"},"Main")," in class ",(0,r.kt)("inlineCode",{parentName:"li"},"Program"),":")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'    public static async Task Main()\n    {\n        var producers = new[]\n        {\n            new Producer("Producer1", s_channel.Writer),\n            new Producer("Producer2",s_channel.Writer),\n            new Producer("Producer3",s_channel.Writer),\n        };\n\n        var producerTasks = new List<Task>();\n\n        foreach (var producer in producers)\n        {\n            var producerTask = producer.Produce();\n            producerTasks.Add(producerTask);\n        }\n\n        var consumers = new[]\n        {\n            new Consumer("Consumer1", s_channel.Reader),\n            new Consumer("Consumer2", s_channel.Reader),\n        };\n\n        var consumerTasks = new List<Task<int>>();\n        foreach (var consumer in consumers)\n        {\n            var consumerTask = consumer.Consume();\n            consumerTasks.Add(consumerTask);\n        }\n\n        await Task.WhenAll(producerTasks);\n\n        s_channel.Writer.Complete();\n\n        var sum = 0;\n        foreach (var consumerTask in consumerTasks)\n        {\n            sum += await consumerTask;\n        }\n\n        System.Console.WriteLine($"Expected sum: {99 * 100 / 2 * producers.Length}");\n        System.Console.WriteLine($"Actual sum: {sum}");\n    }\n')),(0,r.kt)("h3",{id:"run-the-project-3"},(0,r.kt)("strong",{parentName:"h3"},"Run the project")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Execute the project and the output similar to the following will appear:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"$ dotnet run --project Synchronization.MultipleProducersConsumers/Synchronization.MultipleProducersConsumers.csproj\nProducer Producer2 wrote 0 to channel.\nProducer Producer1 wrote 0 to channel.\nProducer Producer1 wrote 1 to channel.\nProducer Producer2 wrote 1 to channel.\nProducer Producer2 wrote 2 to channel.\nProducer Producer1 wrote 2 to channel.\nProducer Producer2 wrote 3 to channel.\nProducer Producer1 wrote 3 to channel.\nConsumer Consumer1 read 0 from channel.\nConsumer Consumer3 read 1 from channel.\n...\nConsumer Consumer2 read 98 from channel.\nConsumer Consumer3 read 96 from channel.\nConsumer Consumer1 read 99 from channel.\nConsumer Consumer2 read 99 from channel.\nExpected sum: 9900\nActual sum: 9900\n")),(0,r.kt)("h2",{id:"exercise-6-provoking-a-deadlock"},(0,r.kt)("strong",{parentName:"h2"},"Exercise 6: Provoking a Deadlock")),(0,r.kt)("p",null,"In this exercise you will provoke a deadlock when two threads are trying to acquire two different locks in the same order."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"deadlock",src:t(6040).Z,width:"720",height:"540"})),(0,r.kt)("h3",{id:"create-a-project-5"},(0,r.kt)("strong",{parentName:"h3"},"Create a Project")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Create a C# Console project, named ",(0,r.kt)("inlineCode",{parentName:"li"},"Synchronization.ProvokingDeadLock")," in solution ",(0,r.kt)("inlineCode",{parentName:"li"},"Synchronization"),":")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"dotnet new console --name Synchronization.ProvokingDeadLock\ndotnet sln add Synchronization.ProvokingDeadLock/Synchronization.ProvokingDeadLock.csproj\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Create and implement class ",(0,r.kt)("inlineCode",{parentName:"li"},"Account")," in new file:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'public class Account\n{\n    private object _locker = new();\n    private readonly string _name;\n    private decimal _balance;\n\n    public Account(string name, decimal balance)\n    {\n        _name = name;\n        _balance = balance;\n    }\n\n    public void Withdraw(decimal amount)\n    {\n        _balance -= amount;\n    }\n\n    public void Deposit(decimal amount)\n    {\n        _balance += amount;\n    }\n\n    public override string ToString()\n    {\n        return $"Ballance: {_balance}";\n    }\n}\n\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Implement method ",(0,r.kt)("inlineCode",{parentName:"li"},"Transfer")," in class ",(0,r.kt)("inlineCode",{parentName:"li"},"Account"),":")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'    public void Transfer(Account other, decimal amount)\n    {\n        if (other is null)\n        {\n            return;\n        }\n\n        var managedThreadId = Environment.CurrentManagedThreadId;\n\n        lock (_locker)\n        {\n            Console.WriteLine($"Account {_name} Thread {managedThreadId} acquired lock 1.");\n            Thread.Sleep(1000);\n\n            Console.WriteLine($"Account {_name} Thread {managedThreadId} trying to acquire lock 2.");\n\n            lock (other._locker)\n            {\n                Console.WriteLine($"Account {_name} Thread {managedThreadId} acquired lock 2.");\n\n                Withdraw(amount);\n                other.Deposit(amount);\n                Console.WriteLine($"Account {_name} Thread {managedThreadId} performed transfer and is releasing lock 2.");\n            }\n\n            Console.WriteLine($"Thread {managedThreadId} is releasing 1.");\n        }\n    }\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Add following fields to class ",(0,r.kt)("inlineCode",{parentName:"li"},"Program"),":")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'    private static readonly Account s_firstAccount = new("First Account", 200);\n    private static readonly Account s_secondAccount = new("Second Account", 300);\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Implement method ",(0,r.kt)("inlineCode",{parentName:"li"},"Main")," in class ",(0,r.kt)("inlineCode",{parentName:"li"},"Program"),":")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'        var t1 = Task.Run(() => s_firstAccount.Transfer(s_secondAccount, 100));\n        //var t2 = Task.Run(() => a.Transfer(b, 100));\n        var t2 = Task.Run(() => s_secondAccount.Transfer(s_firstAccount, 100));\n\n        await Task.WhenAll(t1, t2);\n\n        Console.WriteLine($"Balances: {s_firstAccount} {s_secondAccount}");\n')),(0,r.kt)("h3",{id:"run-the-project-4"},(0,r.kt)("strong",{parentName:"h3"},"Run the project")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Execute the project and the output similar to the following will appear:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"$ dotnet run --project Synchronization.ProvokingDeadLock/Synchronization.ProvokingDeadLock.csproj\nAccount Second Account Thread 6 acquired lock 1.\nAccount First Account Thread 4 acquired lock 1.\nAccount First Account Thread 4 trying to acquire lock 2.\nAccount Second Account Thread 6 trying to acquire lock 2.\n\n")),(0,r.kt)("h2",{id:"exercise-7-avoiding-deadlocks"},(0,r.kt)("strong",{parentName:"h2"},"Exercise 7: Avoiding Deadlocks")),(0,r.kt)("p",null,"In this exercise you will use kernel synchronization primitives to avoid deadlocks situations."),(0,r.kt)("h3",{id:"create-a-project-6"},(0,r.kt)("strong",{parentName:"h3"},"Create a Project")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Create a C# Console project, named ",(0,r.kt)("inlineCode",{parentName:"li"},"Synchronization.Mutexes")," in solution ",(0,r.kt)("inlineCode",{parentName:"li"},"Synchronization"),":")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"dotnet new console --name Synchronization.Mutexes\ndotnet sln add Synchronization.Mutexes/Synchronization.Mutexes.csproj\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Create and implement class ",(0,r.kt)("inlineCode",{parentName:"li"},"Account")," in new file:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'using System;\nusing System.Threading;\n\nnamespace Synchronization.Mutexes;\n\npublic class Account\n{\n    private const int Timeout = 10000;\n    private readonly string _name;\n    private decimal _balance;\n    private readonly Mutex _mutex = new();\n\n    public Account(string name, decimal balance)\n    {\n        _name = name;\n        _balance = balance;\n    }\n\n    public void Withdraw(decimal amount)\n    {\n        _balance -= amount;\n    }\n\n    public void Deposit(decimal amount)\n    {\n        _balance += amount;\n    }\n\n    public override string ToString()\n    {\n        return $"Account: {_name} Ballance: {_balance}";\n    }\n}\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Implement method ",(0,r.kt)("inlineCode",{parentName:"li"},"Transfer")," in class ",(0,r.kt)("inlineCode",{parentName:"li"},"Account"),":")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'    public void Transfer(Account other, decimal amount)\n    {\n        if (other is null)\n        {\n            return;\n        }\n\n        var managedThreadId = Environment.CurrentManagedThreadId;\n\n        Mutex[] lockers = { _mutex, other._mutex };\n\n        if (WaitHandle.WaitAll(lockers, Timeout))\n        {\n            try\n            {\n                Console.WriteLine($"Account {_name} T{managedThreadId}: All locks are acquired.");\n\n                Withdraw(amount);\n                Thread.Sleep(1000);\n                other.Deposit(amount);\n\n                Console.WriteLine($"Account {_name} T{managedThreadId}: Transfer is performed.");\n            }\n            finally\n            {\n                foreach (var mutex in lockers)\n                {\n                    mutex.ReleaseMutex();\n                }\n\n                Console.WriteLine($"Account {_name} T{managedThreadId}: All locks are released.");\n            }\n        }\n    }\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Add following fields to class ",(0,r.kt)("inlineCode",{parentName:"li"},"Program"),":")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'    private static readonly Account s_firstAccount = new("First", 200);\n    private static readonly Account s_secondAccount = new("Second", 300);\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Implement method ",(0,r.kt)("inlineCode",{parentName:"li"},"Main")," in class ",(0,r.kt)("inlineCode",{parentName:"li"},"Program"),":")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'    public static async Task Main()\n    {\n        var t1 = Task.Run(() => s_firstAccount.Transfer(s_secondAccount, 100));\n        var t2 = Task.Run(() => s_firstAccount.Transfer(s_secondAccount, 100));\n        // var t2 = Task.Run(() => s_secondAccount.Transfer(s_firstAccount, 100));\n\n        await Task.WhenAll(t1, t2);\n\n        Console.WriteLine("Balances: {0} {1}", s_firstAccount, s_secondAccount);\n    }\n')),(0,r.kt)("h3",{id:"run-the-project-5"},(0,r.kt)("strong",{parentName:"h3"},"Run the project")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Execute the project and the output similar to the following will appear:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"$ dotnet run --project Synchronization.Mutexes/Synchronization.Mutexes.csproj\nAccount First T4: All locks are acquired.\nAccount First T4: Transfer is performed.\nAccount First T4: All locks are released.\nAccount First T6: All locks are acquired.\nAccount First T6: Transfer is performed.\nAccount First T6: All locks are released.\nBalances: Account: First Ballance: 0 Account: Second Ballance: 500\n")),(0,r.kt)("h2",{id:"homework"},(0,r.kt)("strong",{parentName:"h2"},"Homework")),(0,r.kt)("h3",{id:"setup"},(0,r.kt)("strong",{parentName:"h3"},"Setup")),(0,r.kt)("p",null,"Create ",(0,r.kt)("inlineCode",{parentName:"p"},"data.txt")," file using code below:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'// Program.cs\n//\n// \xa9 2022 FESB in cooperation with Zoraja Consulting. All rights reserved.\n\nusing System;\nusing System.IO;\nusing System.Threading.Tasks;\n\nnamespace Csharp;\n\npublic static class Program\n{\n    private const int NumberOfRows = 100_000_000;\n\n    private static readonly Random s_random = new();\n\n    public static async Task Main()\n    {\n        var userFolder = Environment.GetFolderPath(Environment.SpecialFolder.UserProfile);\n        var outputFilePath = Path.Combine(userFolder, @"Downloads\\data.txt");\n\n        using var outputFileStream = new FileStream(outputFilePath, FileMode.OpenOrCreate);\n        using var streamWriter = new StreamWriter(outputFileStream);\n\n        await streamWriter.WriteLineAsync("Type;OIB;Name;Gender;DateOfBirth;AvgGrade;Paycheck");\n\n        for (var i = 0; i < NumberOfRows; i++)\n        {\n            var personRandomNumber = s_random.Next(0, 11);\n\n            var row = personRandomNumber switch\n            {\n                0 => GetInvalidRowString(),\n                < 6 => GetProfessorRowString(i),\n                _ => GetStudentRowString(i)\n            };\n            await streamWriter.WriteLineAsync(row);\n        }\n    }\n\n    private static string GetProfessorRowString(int rowNumber)\n    {\n        var isProfessorErrorRow = s_random.Next(0, 11) == 5;\n\n        return isProfessorErrorRow\n            ? $"Professor;error;error;error;error;error;error"\n            : $"Professor;{rowNumber * 3478931L % 100000000};Name{rowNumber};{(rowNumber % 2 == 0 ? "Male" : "Female")};11/1/1999;;{rowNumber % 15 * 1000}";\n    }\n\n    private static string GetStudentRowString(int rowNumber)\n    {\n        var isStudentErrorRow = s_random.Next(0, 11) == 5;\n\n        return isStudentErrorRow\n            ? $"Student;error;error;error;error;error;error"\n            : $"Student;{rowNumber * 3478931L % 100000000};Name{rowNumber};{(rowNumber % 2 == 0 ? "Male" : "Female")};11/1/1999;{rowNumber % 5};";\n    }\n\n    private static string GetInvalidRowString()\n    {\n        return $"error;error;error;error;error;error;error";\n    }\n}\n')),(0,r.kt)("p",null,"Your task is to:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"parse these people into appropriate objects (you can reuse code from previous labs):"),(0,r.kt)("li",{parentName:"ul"},"Display in console rows with preserved row number:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"error rows with red color"),(0,r.kt)("li",{parentName:"ul"},"students with grade below ",(0,r.kt)("inlineCode",{parentName:"li"},"1")," with yellow color"),(0,r.kt)("li",{parentName:"ul"},"students with green color"),(0,r.kt)("li",{parentName:"ul"},"professors with blue color"))),(0,r.kt)("li",{parentName:"ul"},"Write rows into files:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"write all invalid rows into ",(0,r.kt)("inlineCode",{parentName:"li"},"error-rows.txt")," file"),(0,r.kt)("li",{parentName:"ul"},"write all students with grade ",(0,r.kt)("inlineCode",{parentName:"li"},"1")," or below into ",(0,r.kt)("inlineCode",{parentName:"li"},"failed-students.txt")," file"),(0,r.kt)("li",{parentName:"ul"},"write all students with grade above ",(0,r.kt)("inlineCode",{parentName:"li"},"1")," into ",(0,r.kt)("inlineCode",{parentName:"li"},"passed-students.txt")," file"),(0,r.kt)("li",{parentName:"ul"},"write all professor into ",(0,r.kt)("inlineCode",{parentName:"li"},"professors.txt")," file"))),(0,r.kt)("li",{parentName:"ul"},"write code that is memory and performance optimized. (Hint: use async await, tasks and producer consumers pattern)")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Notes:")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"This code will generate file which is about 5GB's in size."),(0,r.kt)("li",{parentName:"ul"},"Do not attempt to load whole file into memory at once"),(0,r.kt)("li",{parentName:"ul"},"Use async await where ever you can"),(0,r.kt)("li",{parentName:"ul"},"Throwing exceptions is slow"),(0,r.kt)("li",{parentName:"ul"},"Changing colors with ",(0,r.kt)("inlineCode",{parentName:"li"},"Console.ForegroundColor = ConsoleColor.Yellow"),":",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"might cause race conditions since multiple threads might be outputting to console."),(0,r.kt)("li",{parentName:"ul"},"use following class to encode colors of text in console:")))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'/// <summary>\n/// ANSI text format utility.\n/// </summary>\npublic static class AnsiUtility\n{\n    private const string RedColor = "31";\n    private const string GreenColor = "32";\n    private const string YellowColor = "33";\n    private const string BlueColor = "34";\n    private const string WhiteColor = "37";\n\n    public static string EncodeForegroundWithRedColor(string value)\n    {\n        return Encode(value, RedColor);\n    }\n\n    public static string EncodeForegroundWithGreenColor(string value)\n    {\n        return Encode(value, GreenColor);\n    }\n\n    public static string EncodeForegroundWithYellowColor(string value)\n    {\n        return Encode(value, YellowColor);\n    }\n\n    public static string EncodeForegroundWithBlueColor(string value)\n    {\n        return Encode(value, BlueColor);\n    }\n\n    public static string EncodeForegroundWithWhiteColor(string value)\n    {\n        return Encode(value, WhiteColor);\n    }\n\n    private static string Encode(string value, params object?[] parameters)\n    {\n        return $"\\u001b[{string.Join(";", parameters)}m{value}\\u001b[0m";\n    }\n}\n')))}p.isMDXComponent=!0},1167:(e,n,t)=>{t.d(n,{Z:()=>a});const a=t.p+"assets/images/circular-buffer-de98b6055fa41f99b6a053b4d683ee36.png"},6643:(e,n,t)=>{t.d(n,{Z:()=>a});const a=t.p+"assets/images/coordinating-threads-3b7e34aabf5b3a3b0c3cdf3e6eb6fae1.png"},6040:(e,n,t)=>{t.d(n,{Z:()=>a});const a=t.p+"assets/images/deadlock-4ad5155be0bd23d7e13bf4eb7ffc43e3.png"},3792:(e,n,t)=>{t.d(n,{Z:()=>a});const a=t.p+"assets/images/mutual-exclusion-5ef06c6075a8f8359fe12e9feaf4c581.png"},9262:(e,n,t)=>{t.d(n,{Z:()=>a});const a=t.p+"assets/images/producer-consumer-08192f13113e2fdbf132d12b8292b869.svg"}}]);